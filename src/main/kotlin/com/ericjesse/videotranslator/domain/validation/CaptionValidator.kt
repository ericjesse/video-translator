package com.ericjesse.videotranslator.domain.validation

import com.ericjesse.videotranslator.domain.model.Language
import com.ericjesse.videotranslator.domain.model.SubtitleEntry
import com.ericjesse.videotranslator.domain.model.Subtitles
import io.github.oshai.kotlinlogging.KotlinLogging

private val logger = KotlinLogging.logger {}

/**
 * Thresholds for caption validation.
 */
object CaptionThresholds {
    /** Minimum number of subtitle entries to be considered valid */
    const val MIN_ENTRIES = 1

    /** Minimum average text length per entry (chars) */
    const val MIN_AVG_TEXT_LENGTH = 3

    /** Maximum subtitle line length before warning (chars) */
    const val MAX_LINE_LENGTH = 80

    /** Maximum subtitle line length before requiring split (chars) */
    const val CRITICAL_LINE_LENGTH = 120

    /** Minimum speech ratio (entries with text / total possible entries) */
    const val MIN_SPEECH_RATIO = 0.1

    /** Threshold for considering captions as low quality */
    const val LOW_QUALITY_THRESHOLD = 0.5
}

/**
 * Represents information about available captions.
 */
data class CaptionInfo(
    val languageCode: String,
    val languageName: String,
    val isAutoGenerated: Boolean,
    val isDefault: Boolean = false
)

/**
 * Result of caption validation.
 */
sealed class CaptionValidationResult {
    /** Captions are valid */
    data object Valid : CaptionValidationResult()

    /** Captions are valid but have warnings */
    data class ValidWithWarnings(
        val warnings: List<CaptionWarning>
    ) : CaptionValidationResult()

    /** Captions are invalid */
    data class Invalid(
        val error: CaptionError
    ) : CaptionValidationResult()

    fun isValid(): Boolean = this is Valid || this is ValidWithWarnings
}

/**
 * Types of caption warnings.
 */
sealed class CaptionWarning {
    abstract val message: String
    abstract val suggestion: String?

    /** Auto-generated captions may have errors */
    data class AutoGenerated(
        val language: String
    ) : CaptionWarning() {
        override val message = "Using auto-generated captions for $language"
        override val suggestion = "Auto-generated captions may contain errors. Consider reviewing the translation."
    }

    /** Caption language may not match expected */
    data class LanguageMismatch(
        val expectedLanguage: String?,
        val detectedLanguage: String
    ) : CaptionWarning() {
        override val message = if (expectedLanguage != null) {
            "Expected $expectedLanguage captions but detected $detectedLanguage"
        } else {
            "Detected language: $detectedLanguage"
        }
        override val suggestion = "Verify the source language is correct for accurate translation."
    }

    /** Some subtitle lines are very long */
    data class LongLines(
        val count: Int,
        val maxLength: Int
    ) : CaptionWarning() {
        override val message = "$count subtitle lines exceed recommended length (max: $maxLength chars)"
        override val suggestion = "Long lines may display poorly. Consider manual review."
    }

    /** Captions contain special characters that may affect display */
    data class SpecialCharacters(
        val types: List<String>
    ) : CaptionWarning() {
        override val message = "Captions contain special characters: ${types.joinToString(", ")}"
        override val suggestion = "Special characters will be preserved but may display differently."
    }

    /** Low caption quality detected */
    data class LowQuality(
        val qualityScore: Float,
        val issues: List<String>
    ) : CaptionWarning() {
        override val message = "Caption quality may be low (score: ${(qualityScore * 100).toInt()}%)"
        override val suggestion = "Issues detected: ${issues.joinToString("; ")}. Consider using transcription instead."
    }

    /** Multiple caption tracks available */
    data class MultipleTracksAvailable(
        val tracks: List<CaptionInfo>,
        val selected: CaptionInfo
    ) : CaptionWarning() {
        override val message = "Multiple caption tracks available: ${tracks.map { it.languageName }.joinToString(", ")}"
        override val suggestion = "Selected: ${selected.languageName}${if (selected.isAutoGenerated) " (auto-generated)" else ""}. " +
                "Change source language to use a different track."
    }

    /** Very few captions for video duration */
    data class SparseCaptions(
        val entryCount: Int,
        val expectedMinimum: Int
    ) : CaptionWarning() {
        override val message = "Only $entryCount caption entries found (expected at least $expectedMinimum)"
        override val suggestion = "Video may have limited speech content or poor caption coverage."
    }
}

/**
 * Types of caption errors.
 */
sealed class CaptionError {
    abstract val code: String
    abstract val message: String
    abstract val suggestion: String?
    abstract val fallbackToTranscription: Boolean

    /** No captions available */
    data object NoCaptions : CaptionError() {
        override val code = "NO_CAPTIONS"
        override val message = "No captions are available for this video"
        override val suggestion = "The video will be transcribed using speech recognition."
        override val fallbackToTranscription = true
    }

    /** No captions in requested language */
    data class NoMatchingLanguage(
        val requestedLanguage: String,
        val availableLanguages: List<String>
    ) : CaptionError() {
        override val code = "NO_MATCHING_LANGUAGE"
        override val message = "No captions available in $requestedLanguage"
        override val suggestion = if (availableLanguages.isNotEmpty()) {
            "Available languages: ${availableLanguages.joinToString(", ")}. " +
                    "Will use transcription instead."
        } else {
            "Will use transcription instead."
        }
        override val fallbackToTranscription = true
    }

    /** Caption extraction failed */
    data class ExtractionFailed(
        val reason: String?
    ) : CaptionError() {
        override val code = "EXTRACTION_FAILED"
        override val message = "Failed to extract captions: ${reason ?: "unknown error"}"
        override val suggestion = "Will attempt transcription instead."
        override val fallbackToTranscription = true
    }

    /** Captions are empty */
    data object EmptyCaptions : CaptionError() {
        override val code = "EMPTY_CAPTIONS"
        override val message = "Caption track exists but contains no text"
        override val suggestion = "Will use transcription instead."
        override val fallbackToTranscription = true
    }

    /** No speech content detected */
    data object NoSpeechContent : CaptionError() {
        override val code = "NO_SPEECH"
        override val message = "No speech content found in video"
        override val suggestion = "This video appears to contain only music or silence. " +
                "Translation requires spoken content."
        override val fallbackToTranscription = false
    }

    /** Captions are corrupted or malformed */
    data class CorruptedCaptions(
        val details: String?
    ) : CaptionError() {
        override val code = "CORRUPTED_CAPTIONS"
        override val message = "Caption data appears to be corrupted"
        override val suggestion = "Will attempt transcription instead."
        override val fallbackToTranscription = true
    }
}

/**
 * Validates caption/subtitle content for edge cases.
 */
class CaptionValidator {

    /**
     * Validates subtitle content.
     *
     * @param subtitles The subtitles to validate.
     * @param expectedLanguage Expected source language, if any.
     * @param videoDurationMs Video duration in milliseconds for coverage analysis.
     * @return CaptionValidationResult indicating validity and any warnings.
     */
    fun validate(
        subtitles: Subtitles,
        expectedLanguage: Language? = null,
        videoDurationMs: Long = 0
    ): CaptionValidationResult {
        val warnings = mutableListOf<CaptionWarning>()

        // Check for empty captions
        if (subtitles.entries.isEmpty()) {
            return CaptionValidationResult.Invalid(CaptionError.EmptyCaptions)
        }

        // Check average text length
        val avgLength = subtitles.entries.map { it.text.length }.average()
        if (avgLength < CaptionThresholds.MIN_AVG_TEXT_LENGTH) {
            return CaptionValidationResult.Invalid(CaptionError.NoSpeechContent)
        }

        // Check for language mismatch
        if (expectedLanguage != null && subtitles.language != expectedLanguage) {
            warnings.add(CaptionWarning.LanguageMismatch(
                expectedLanguage = expectedLanguage.displayName,
                detectedLanguage = subtitles.language.displayName
            ))
        }

        // Check for long lines
        val longLines = subtitles.entries.filter { entry ->
            entry.text.lines().any { it.length > CaptionThresholds.MAX_LINE_LENGTH }
        }
        if (longLines.isNotEmpty()) {
            val maxLen = longLines.flatMap { it.text.lines() }.maxOfOrNull { it.length } ?: 0
            warnings.add(CaptionWarning.LongLines(longLines.size, maxLen))
        }

        // Check for special characters
        val specialChars = detectSpecialCharacters(subtitles)
        if (specialChars.isNotEmpty()) {
            warnings.add(CaptionWarning.SpecialCharacters(specialChars))
        }

        // Check caption coverage if duration provided
        if (videoDurationMs > 0) {
            val expectedMinEntries = (videoDurationMs / 1000 / 5).toInt().coerceAtLeast(1) // ~1 entry per 5 seconds
            if (subtitles.entries.size < expectedMinEntries * CaptionThresholds.MIN_SPEECH_RATIO) {
                warnings.add(CaptionWarning.SparseCaptions(
                    entryCount = subtitles.entries.size,
                    expectedMinimum = (expectedMinEntries * CaptionThresholds.MIN_SPEECH_RATIO).toInt()
                ))
            }
        }

        // Calculate quality score
        val qualityScore = calculateQualityScore(subtitles)
        if (qualityScore < CaptionThresholds.LOW_QUALITY_THRESHOLD) {
            val issues = detectQualityIssues(subtitles)
            warnings.add(CaptionWarning.LowQuality(qualityScore, issues))
        }

        return if (warnings.isEmpty()) {
            CaptionValidationResult.Valid
        } else {
            CaptionValidationResult.ValidWithWarnings(warnings)
        }
    }

    /**
     * Validates available caption tracks.
     *
     * @param availableTracks List of available caption tracks.
     * @param preferredLanguage Preferred source language.
     * @param preferManual Whether to prefer manual captions over auto-generated.
     * @return The best matching track, or null if none suitable.
     */
    fun selectBestTrack(
        availableTracks: List<CaptionInfo>,
        preferredLanguage: Language?,
        preferManual: Boolean = true
    ): Pair<CaptionInfo?, CaptionWarning?> {
        if (availableTracks.isEmpty()) {
            return null to null
        }

        // Filter by language if specified
        val languageMatches = if (preferredLanguage != null) {
            availableTracks.filter { it.languageCode.startsWith(preferredLanguage.code) }
        } else {
            availableTracks
        }

        val candidates = languageMatches.ifEmpty { availableTracks }

        // Prefer manual captions if requested
        val sorted = if (preferManual) {
            candidates.sortedWith(compareBy(
                { it.isAutoGenerated },
                { !it.isDefault }
            ))
        } else {
            candidates.sortedByDescending { it.isDefault }
        }

        val selected = sorted.firstOrNull() ?: return null to null

        // Generate warning if needed
        val warning = when {
            availableTracks.size > 1 -> {
                CaptionWarning.MultipleTracksAvailable(availableTracks, selected)
            }
            selected.isAutoGenerated -> {
                CaptionWarning.AutoGenerated(selected.languageName)
            }
            preferredLanguage != null && !selected.languageCode.startsWith(preferredLanguage.code) -> {
                CaptionWarning.LanguageMismatch(
                    expectedLanguage = preferredLanguage.displayName,
                    detectedLanguage = selected.languageName
                )
            }
            else -> null
        }

        return selected to warning
    }

    /**
     * Processes subtitle entries for long lines by splitting them.
     *
     * @param subtitles Original subtitles.
     * @param maxLineLength Maximum characters per line.
     * @return Processed subtitles with split lines.
     */
    fun splitLongLines(
        subtitles: Subtitles,
        maxLineLength: Int = CaptionThresholds.MAX_LINE_LENGTH
    ): Subtitles {
        val processedEntries = subtitles.entries.map { entry ->
            val splitText = splitTextIntoLines(entry.text, maxLineLength)
            entry.copy(text = splitText)
        }

        return subtitles.copy(entries = processedEntries)
    }

    /**
     * Detects special characters in subtitles.
     */
    private fun detectSpecialCharacters(subtitles: Subtitles): List<String> {
        val types = mutableSetOf<String>()
        val allText = subtitles.entries.joinToString(" ") { it.text }

        // Check for emojis
        if (EMOJI_REGEX.containsMatchIn(allText)) {
            types.add("emojis")
        }

        // Check for musical notes
        if (allText.contains("â™ª") || allText.contains("â™«") || allText.contains("ðŸŽµ")) {
            types.add("musical notes")
        }

        // Check for special Unicode
        if (allText.any { it.code > 0x2000 && it.code < 0x3000 }) {
            types.add("special symbols")
        }

        // Check for RTL characters
        if (RTL_REGEX.containsMatchIn(allText)) {
            types.add("right-to-left text")
        }

        return types.toList()
    }

    /**
     * Calculates a quality score for captions.
     */
    private fun calculateQualityScore(subtitles: Subtitles): Float {
        if (subtitles.entries.isEmpty()) return 0f

        var score = 1.0f
        val entries = subtitles.entries

        // Penalize very short entries
        val shortEntries = entries.count { it.text.length < 5 }
        score -= (shortEntries.toFloat() / entries.size) * 0.2f

        // Penalize entries with no alphanumeric content
        val nonTextEntries = entries.count { !it.text.any { c -> c.isLetterOrDigit() } }
        score -= (nonTextEntries.toFloat() / entries.size) * 0.3f

        // Penalize repeated entries
        val uniqueTexts = entries.map { it.text.trim().lowercase() }.toSet()
        val repetitionRatio = 1 - (uniqueTexts.size.toFloat() / entries.size)
        score -= repetitionRatio * 0.2f

        // Penalize timing issues
        val timingIssues = entries.zipWithNext().count { (a, b) ->
            a.endTime > b.startTime // Overlapping
        }
        score -= (timingIssues.toFloat() / entries.size.coerceAtLeast(1)) * 0.3f

        return score.coerceIn(0f, 1f)
    }

    /**
     * Detects specific quality issues in captions.
     */
    private fun detectQualityIssues(subtitles: Subtitles): List<String> {
        val issues = mutableListOf<String>()
        val entries = subtitles.entries

        // Check for short entries
        val shortRatio = entries.count { it.text.length < 5 }.toFloat() / entries.size
        if (shortRatio > 0.2) {
            issues.add("many very short entries")
        }

        // Check for timing overlaps
        val overlaps = entries.zipWithNext().count { (a, b) -> a.endTime > b.startTime }
        if (overlaps > entries.size * 0.1) {
            issues.add("timing overlaps detected")
        }

        // Check for duplicate content
        val uniqueRatio = entries.map { it.text.trim().lowercase() }.toSet().size.toFloat() / entries.size
        if (uniqueRatio < 0.8) {
            issues.add("repeated content")
        }

        // Check for filler entries
        val fillerPatterns = listOf("[Music]", "[Applause]", "[Laughter]", "...", "â™ª")
        val fillerCount = entries.count { entry ->
            fillerPatterns.any { entry.text.contains(it, ignoreCase = true) }
        }
        if (fillerCount > entries.size * 0.3) {
            issues.add("high ratio of non-speech content")
        }

        return issues
    }

    /**
     * Splits text into lines of maximum length.
     */
    private fun splitTextIntoLines(text: String, maxLength: Int): String {
        val lines = text.split("\n")
        val result = mutableListOf<String>()

        for (line in lines) {
            if (line.length <= maxLength) {
                result.add(line)
                continue
            }

            // Split at word boundaries
            val words = line.split(" ")
            var currentLine = StringBuilder()

            for (word in words) {
                if (currentLine.isEmpty()) {
                    currentLine.append(word)
                } else if (currentLine.length + 1 + word.length <= maxLength) {
                    currentLine.append(" ").append(word)
                } else {
                    result.add(currentLine.toString())
                    currentLine = StringBuilder(word)
                }
            }

            if (currentLine.isNotEmpty()) {
                result.add(currentLine.toString())
            }
        }

        return result.joinToString("\n")
    }

    companion object {
        private val EMOJI_REGEX = Regex("[\\p{So}\\p{Cs}]")
        private val RTL_REGEX = Regex("[\\u0590-\\u05FF\\u0600-\\u06FF\\u0750-\\u077F]")

        /**
         * Determines if auto-generated captions should be used.
         */
        fun shouldUseAutoCaptions(
            hasManualCaptions: Boolean,
            autoLanguage: String?,
            preferredLanguage: Language?
        ): Boolean {
            if (hasManualCaptions) return false
            if (autoLanguage == null) return false
            if (preferredLanguage == null) return true
            return autoLanguage.startsWith(preferredLanguage.code)
        }
    }
}

/**
 * Extension to validate subtitles.
 */
fun Subtitles.validate(
    expectedLanguage: Language? = null,
    videoDurationMs: Long = 0
): CaptionValidationResult {
    return CaptionValidator().validate(this, expectedLanguage, videoDurationMs)
}
