package com.ericjesse.videotranslator.domain.validation

import com.ericjesse.videotranslator.domain.model.VideoInfo
import io.github.oshai.kotlinlogging.KotlinLogging

private val logger = KotlinLogging.logger {}

/**
 * Thresholds for video duration validation.
 */
object VideoDurationThresholds {
    /** Minimum video duration in seconds */
    const val MIN_DURATION_SECONDS = 5L

    /** Short video threshold in seconds (warn about minimal content) */
    const val SHORT_VIDEO_SECONDS = 30L

    /** Long video threshold in seconds (2 hours - warn about processing time) */
    const val LONG_VIDEO_SECONDS = 7200L

    /** Very long video threshold in seconds (4 hours - may fail) */
    const val VERY_LONG_VIDEO_SECONDS = 14400L

    /** Maximum supported duration in seconds (8 hours) */
    const val MAX_DURATION_SECONDS = 28800L
}

/**
 * Result of video validation.
 */
sealed class VideoValidationResult {
    /** Video is valid and ready for processing */
    data object Valid : VideoValidationResult()

    /** Video is valid but has warnings */
    data class ValidWithWarning(
        val warning: VideoWarning
    ) : VideoValidationResult()

    /** Video is invalid and cannot be processed */
    data class Invalid(
        val error: VideoError
    ) : VideoValidationResult()

    fun isValid(): Boolean = this is Valid || this is ValidWithWarning
}

/**
 * Types of video warnings.
 */
sealed class VideoWarning {
    abstract val message: String
    abstract val suggestion: String?

    /** Video is very short */
    data class ShortVideo(
        val durationSeconds: Long
    ) : VideoWarning() {
        override val message = "This video is only ${durationSeconds} seconds long"
        override val suggestion = "Short videos may have limited content for translation"
    }

    /** Video is very long */
    data class LongVideo(
        val durationSeconds: Long,
        val estimatedMinutes: Long
    ) : VideoWarning() {
        override val message = "This video is ${durationSeconds / 3600} hours long"
        override val suggestion = "Processing may take approximately $estimatedMinutes minutes. " +
                "Consider processing in the background."
    }

    /** Video is extremely long */
    data class VeryLongVideo(
        val durationSeconds: Long
    ) : VideoWarning() {
        override val message = "This video is over ${durationSeconds / 3600} hours long"
        override val suggestion = "Very long videos may require significant time and resources. " +
                "Consider splitting the video into smaller segments."
    }

    /** Auto-generated captions detected */
    data class AutoGeneratedCaptions(
        val language: String
    ) : VideoWarning() {
        override val message = "Using auto-generated captions for $language"
        override val suggestion = "Auto-generated captions may contain errors. " +
                "Review the translation for accuracy."
    }

    /** Multiple caption languages available */
    data class MultipleCaptionLanguages(
        val languages: List<String>,
        val selectedLanguage: String
    ) : VideoWarning() {
        override val message = "Multiple caption languages available: ${languages.joinToString(", ")}"
        override val suggestion = "Using $selectedLanguage captions. " +
                "You can change the source language in settings."
    }
}

/**
 * Types of video errors.
 */
sealed class VideoError {
    abstract val code: String
    abstract val message: String
    abstract val suggestion: String?
    abstract val retryable: Boolean

    /** Video is too short */
    data class TooShort(
        val durationSeconds: Long
    ) : VideoError() {
        override val code = "VIDEO_TOO_SHORT"
        override val message = "Video is too short (${durationSeconds}s). Minimum is ${VideoDurationThresholds.MIN_DURATION_SECONDS}s."
        override val suggestion = "Please select a video with more content."
        override val retryable = false
    }

    /** Video exceeds maximum duration */
    data class TooLong(
        val durationSeconds: Long
    ) : VideoError() {
        override val code = "VIDEO_TOO_LONG"
        override val message = "Video exceeds maximum duration of ${VideoDurationThresholds.MAX_DURATION_SECONDS / 3600} hours"
        override val suggestion = "Please split the video into smaller segments before processing."
        override val retryable = false
    }

    /** Live stream detected */
    data object LiveStream : VideoError() {
        override val code = "LIVE_STREAM"
        override val message = "Live streams cannot be translated"
        override val suggestion = "Wait for the stream to end and the VOD to be available, then try again."
        override val retryable = false
    }

    /** Video is private */
    data object PrivateVideo : VideoError() {
        override val code = "PRIVATE_VIDEO"
        override val message = "This video is private and cannot be accessed"
        override val suggestion = "Ask the video owner to make it public or unlisted."
        override val retryable = false
    }

    /** Video has been deleted */
    data object DeletedVideo : VideoError() {
        override val code = "DELETED_VIDEO"
        override val message = "This video has been deleted or removed"
        override val suggestion = "The video is no longer available on YouTube."
        override val retryable = false
    }

    /** Video is age-restricted */
    data object AgeRestricted : VideoError() {
        override val code = "AGE_RESTRICTED"
        override val message = "This video is age-restricted"
        override val suggestion = "Age-restricted videos require authentication which is not currently supported. " +
                "Try using a video downloader that supports authentication."
        override val retryable = false
    }

    /** Video is geo-restricted */
    data class GeoRestricted(
        val availableCountries: List<String>? = null
    ) : VideoError() {
        override val code = "GEO_RESTRICTED"
        override val message = "This video is not available in your region"
        override val suggestion = if (availableCountries != null && availableCountries.isNotEmpty()) {
            "This video is only available in: ${availableCountries.take(5).joinToString(", ")}. " +
                    "Consider using a VPN to access it."
        } else {
            "Consider using a VPN to access content from a different region."
        }
        override val retryable = false
    }

    /** Video requires payment/subscription */
    data object PaidContent : VideoError() {
        override val code = "PAID_CONTENT"
        override val message = "This video requires a purchase or subscription"
        override val suggestion = "Premium content cannot be downloaded. " +
                "Please purchase access through YouTube."
        override val retryable = false
    }

    /** Video is unavailable for unknown reason */
    data class Unavailable(
        val reason: String? = null
    ) : VideoError() {
        override val code = "VIDEO_UNAVAILABLE"
        override val message = reason ?: "This video is unavailable"
        override val suggestion = "The video may have been removed or made private. " +
                "Check if the URL is correct."
        override val retryable = true
    }

    /** Copyright claim prevents access */
    data object CopyrightBlocked : VideoError() {
        override val code = "COPYRIGHT_BLOCKED"
        override val message = "This video is blocked due to copyright claims"
        override val suggestion = "The content owner has restricted access to this video."
        override val retryable = false
    }

    /** Video has no audio track */
    data object NoAudio : VideoError() {
        override val code = "NO_AUDIO"
        override val message = "This video has no audio track"
        override val suggestion = "Translation requires audio content. " +
                "Please select a video with spoken content."
        override val retryable = false
    }

    /** No speech detected in video */
    data object NoSpeech : VideoError() {
        override val code = "NO_SPEECH"
        override val message = "No speech detected in this video"
        override val suggestion = "The video appears to contain only music or no audio. " +
                "Translation requires spoken content."
        override val retryable = false
    }
}

/**
 * Validates video information for edge cases.
 */
class VideoValidator {

    /**
     * Validates a video's basic properties.
     *
     * @param videoInfo The video information to validate.
     * @return ValidationResult indicating if the video can be processed.
     */
    fun validate(videoInfo: VideoInfo): VideoValidationResult {
        val durationSeconds = videoInfo.duration / 1000

        // Check minimum duration
        if (durationSeconds < VideoDurationThresholds.MIN_DURATION_SECONDS) {
            return VideoValidationResult.Invalid(
                VideoError.TooShort(durationSeconds)
            )
        }

        // Check maximum duration
        if (durationSeconds > VideoDurationThresholds.MAX_DURATION_SECONDS) {
            return VideoValidationResult.Invalid(
                VideoError.TooLong(durationSeconds)
            )
        }

        // Check for warnings
        return when {
            durationSeconds < VideoDurationThresholds.SHORT_VIDEO_SECONDS -> {
                VideoValidationResult.ValidWithWarning(
                    VideoWarning.ShortVideo(durationSeconds)
                )
            }
            durationSeconds > VideoDurationThresholds.VERY_LONG_VIDEO_SECONDS -> {
                VideoValidationResult.ValidWithWarning(
                    VideoWarning.VeryLongVideo(durationSeconds)
                )
            }
            durationSeconds > VideoDurationThresholds.LONG_VIDEO_SECONDS -> {
                // Estimate processing time (roughly 1/10th of video duration)
                val estimatedMinutes = durationSeconds / 60 / 10
                VideoValidationResult.ValidWithWarning(
                    VideoWarning.LongVideo(durationSeconds, estimatedMinutes)
                )
            }
            else -> VideoValidationResult.Valid
        }
    }

    /**
     * Validates a video URL before fetching info.
     * This is a lightweight check for obvious issues.
     *
     * @param url The YouTube URL to validate.
     * @return ValidationResult or null if URL format is valid.
     */
    fun validateUrl(url: String): VideoValidationResult? {
        // Check for live stream indicators in URL
        if (url.contains("/live/") || url.contains("live_stream")) {
            return VideoValidationResult.Invalid(VideoError.LiveStream)
        }

        return null
    }

    /**
     * Parses yt-dlp error output and returns appropriate VideoError.
     *
     * @param errorOutput The stderr output from yt-dlp.
     * @return VideoError if a known error pattern is matched, null otherwise.
     */
    fun parseYtDlpError(errorOutput: String): VideoError? {
        val lowerError = errorOutput.lowercase()

        return when {
            // Live stream detection
            lowerError.contains("is_live") ||
            lowerError.contains("live stream") ||
            lowerError.contains("this live event will begin") -> {
                VideoError.LiveStream
            }

            // Private video
            lowerError.contains("private video") ||
            lowerError.contains("video is private") -> {
                VideoError.PrivateVideo
            }

            // Deleted video
            lowerError.contains("video unavailable") && lowerError.contains("removed") ||
            lowerError.contains("this video has been removed") ||
            lowerError.contains("video has been deleted") -> {
                VideoError.DeletedVideo
            }

            // Age-restricted
            lowerError.contains("sign in to confirm your age") ||
            lowerError.contains("age-restricted") ||
            lowerError.contains("age restricted") ||
            lowerError.contains("confirm your age") -> {
                VideoError.AgeRestricted
            }

            // Geo-restricted
            lowerError.contains("not available in your country") ||
            lowerError.contains("geo restriction") ||
            lowerError.contains("blocked in your country") ||
            lowerError.contains("uploader has not made this video available") -> {
                // Try to extract available countries
                val countriesMatch = Regex("available in: ([A-Z, ]+)").find(errorOutput)
                val countries = countriesMatch?.groupValues?.get(1)?.split(",")?.map { it.trim() }
                VideoError.GeoRestricted(countries)
            }

            // Paid content
            lowerError.contains("requires payment") ||
            lowerError.contains("requires purchase") ||
            lowerError.contains("premium content") ||
            lowerError.contains("members only") -> {
                VideoError.PaidContent
            }

            // Copyright blocked
            lowerError.contains("copyright") ||
            lowerError.contains("blocked on copyright grounds") -> {
                VideoError.CopyrightBlocked
            }

            // Generic unavailable
            lowerError.contains("video unavailable") ||
            lowerError.contains("video is unavailable") -> {
                // Extract reason if possible
                val reasonMatch = Regex("video unavailable[:.] (.+)").find(lowerError)
                VideoError.Unavailable(reasonMatch?.groupValues?.get(1))
            }

            else -> null
        }
    }

    /**
     * Estimates processing time for a video.
     *
     * @param durationSeconds Video duration in seconds.
     * @return Estimated processing time in minutes.
     */
    fun estimateProcessingTime(durationSeconds: Long): Long {
        // Rough estimate: download (1/10) + transcribe (1/5) + translate (1/20) + render (1/10)
        // Total: roughly 1/3 to 1/2 of video duration
        return (durationSeconds / 60 / 3).coerceAtLeast(1)
    }

    companion object {
        /**
         * Checks if a URL appears to be a live stream.
         */
        fun isLikelyLiveStream(url: String): Boolean {
            return url.contains("/live/") ||
                    url.contains("live_stream") ||
                    url.contains("/live") && url.contains("youtube")
        }

        /**
         * Formats duration for display.
         */
        fun formatDuration(durationSeconds: Long): String {
            val hours = durationSeconds / 3600
            val minutes = (durationSeconds % 3600) / 60
            val seconds = durationSeconds % 60

            return when {
                hours > 0 -> String.format("%d:%02d:%02d", hours, minutes, seconds)
                else -> String.format("%d:%02d", minutes, seconds)
            }
        }
    }
}

/**
 * Extension to check if VideoInfo represents a potentially problematic video.
 */
fun VideoInfo.validate(): VideoValidationResult {
    return VideoValidator().validate(this)
}
